#+STARTUP: overview

* 使用linux当做服务器



* 知识那么多, 我们应该怎么做

  1. 极致的事情必定是简单的
     以一个事情为基点 然后去专供一件事情
     最简单的比如以mac系统为起点, 去实现自己想做的事情

     说白了就是熟悉命令行, 然后去完成一系列事情. mac只是一个起点, 最重要的还是后面要处理的事情。

     mac --> 熟悉的系统, 对事情的效率有非常大的提高
     git --> 版本管理, 方便自己随时回退
     gitlab --> 团队管理， 非个人使用
     hexo --> 博客记录，博客只是作为记录使用, 无法真正做到梳理知识体系

     以mac为基础, git, hexo辅助, 去完成一些事情. 
     真正的目标, 比如黑客, 比如赚钱的项目.  相信技术是可以赚钱的, 没有赚钱只是说明技术还没有到位

  2. 心态决定道路
     没有好的心态, 很难走下去
     
     荣辱不惊. 得意时不洋洋得意, 失意时不落落寡欢


* autotools实际使用

  1. 发布时候 提供./configure目录之前的东西即可
  2. 文件夹准备
     include -- 放置头文件
     src     -- 放置源文件


** 疑问
   1. autoscan生成的.scan文件中AC_INIT和AM_INIT_AUTOMAKE的具体差异

   2. 完成ya-snippt的整理

   3. 子目录Makefile.am
      如果子目录下Makefile.am目标为lib, 则automake可以正常通过,  ./configure也可以正常运行. 
      前提是依赖于root/configure.am中需要添加该宏指令: AC_PROG_RANLIB（生成静态库）

      如果子目录下Makefile.am目标为program, 则automake可以正常运行, 但是子目录下并没有生成Makefile.in.暂时还不知道问题在哪

   4. 返回指针 还是返回引用

   

** 记录
   1. std::string本身没有格式化的函数, 使用的是sprintf
      printf  将目标格式化 并输出到标准输出
      sprintf 将目标格式化 并输出到目标变量中
   2. c++ 纯虚函数 是=0
      virtual void Display () = 0; // 纯虚函数
      最后面的“=0”并不表示函数返回值为0，它只起形式上的作用，告诉编译系统“这是虚函数”
   3. extern void *memset(void *buffer, int c, int count)        
      buffer：为指针或是数组,
      c：是赋给buffer的值,
      count：是buffer的长度.

      count不能使用sizeof运算符, sizeof求的是内存中的字节数(char数目)
