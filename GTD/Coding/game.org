#TITLE 棋牌麻将游戏框架整理

* 游戏整体架构

  | 服务器名字 | 进程名字       | 所需信息                                  | 信息来源                           |
  |------------+----------------+-------------------------------------------+------------------------------------|
  | A PC       | 协调服务器     | NULL                                      |                                    |
  |------------+----------------+-------------------------------------------+------------------------------------|
  | B PC       | 登录服务器     | 1. A 的地址和端口(协调服务器进程)         | frame::Define.h中配置              |
  |            |                | 2. S1的地址和端口(platformDB数据库进程)   | kernel::DataBase.h中配置           |
  |            |                | 3. S2的地址和端口(AccountsDB数据库的进程) | kernel::DataBase.h中配置           |
  |            |                | 4. S1的数据库的账号密码 -- 读权限         | kernel::DataBase.h中配置           |
  |            |                | 5. S2的数据库的账号密码 -- 读写权限       | kernel::DataBase.h配置             |
  |            |                | 6. C 的地址和端口(游戏服务器进程)         | S1中获取                           |
  |------------+----------------+-------------------------------------------+------------------------------------|
  | C PC       | 游戏服务器     | 1. A 的地址和端口(协调服务器进程)         | frame::Define.h中配置              |
  |            |                | 2. S1的地址和端口(PlatformDB数据库进程)   | kernel::DataBase.h中配置           |
  |            |                | 3. S3的地址和端口(游戏信息库的进程)       | kernel::DataBase.h配置             |
  |            |                | 4. S1的数据库的账号密码 -- 读权限         | kernel::DataBase.h配置             |
  |            |                | 5. S3的数据库的账号密码 -- 读写权限       | kernel::DataBase.h配置             |
  |------------+----------------+-------------------------------------------+------------------------------------|
  | S1         | platformDB进程 | 1. C 的地址和端口                         | 手动写入数据库中配置               |
  |            |                | 2. DLL的信息 -- 这里是DLL的名字           | 手动配置, 数据库与编译文件一致即可 |
  |------------+----------------+-------------------------------------------+------------------------------------|
  | S2         | AccountsDB进程 | NULL                                      |                                    |
  |------------+----------------+-------------------------------------------+------------------------------------|
  | S3         | 游戏信息库进程 | NULL                                      |                                    |
  |------------+----------------+-------------------------------------------+------------------------------------|
  | client     | 客户端进程     | 1. B 的地址和端口(登录服务器进程)         | 配置文件AppConfig.json             |
  |            |                | 2. C 的地址和端口(游戏服务器进程)         | 登录服务器告知                     |
  |------------+----------------+-------------------------------------------+------------------------------------|

  1. 备注1: S1中增加Dll信息的原因
     服务器框架是通用的, 所以需要区分子游戏.
     子游戏区分的标志在代码中(内部)是kindID,  外部是dll名字
     不区分外部的话, 理论上是可以的, 因为在加载的时候可以选择kindID和kindName
     但是不方便管理, 所以在外部也区分了, 即增加了dll名字的信息


* 游戏框架整理 -- server
** 约定俗称
*** socket相关
    1. socketID为32位, 低16位为wBindIndex, 标志用户
       所以最大的socket连接数为16位, 即65536 
       
       这个里面是 真实用户 + 机器总数

       代码里面 
       真实用户的连接数目为 256,  受控变量为m_pNormalParameter  0 - 256
       机器用户的连接数目为 256,  受控变量为m_pAndroidParameter, 0x2000 - 0x2000+256
        
       在游戏付的AttempSink里面还有2个变量
       m_ServerUserManager   真实用户列表
       m_AndroidUserManager  机器人列表
       
*** 列表理解
    加载列表  CT_LOAD_DB_GAME_LIST 就是读取数据库配置的开始
  1. 最外层是 GameTypeItem
     牌类游戏
     棋类游戏
     麻将类游戏
     休闲类游戏
     捕鱼类游戏
     
  读取时候 根据SortID依次排序
  
  2. 第二层 是 GameKindItem
     比如
     
     type       kind     
     棋牌游戏 --| 
     斗地主
     扎金花
     
  3. 第三层是 GameNodeItem
     比如
     
     type       kind          node
     棋牌游戏 --|
     斗地主  --| 
     网通一区
     网通二区     

*** 消息号
  1. network标志的函数 处理server与client的消息
  2. socket标志的函数  处理server之间的消息
*** dll加载流程
  A： dll自身的名字
  B:  dll中配置的信息 -- 代码中的
  C:  dll rc中的信息
  D:  数据库中的信息

  之前的加载流程:
  1. GameServer.exe会寻找GameGameItem表中的D.Dll
  2. 如果A.dll == D.dll,  则可以加载A.dll   -- 这个是系统函数决定的, 无法修改. 即A.dll必须等于D.dll
  3. 如果C.Version不存在, 则会加载失败 -- 这个可以修改掉, 但更优的做法是在程序中配置C.Version（取代rc中的配置）
  4. 如果A.Version != D.Version 则只是标红提示 但仍然可以加载

  修改之后的加载流程:
  1. GameServer.exe 寻找GameGameItem中的D.dll
  2. 如果A.dll == D.dll,  则可以加载A.dll   -- 这个是系统函数决定的, 无法修改. 即A.dll必须等于D.dll
  3. 如果B.dll中的版本信息 == framework,  则可以正常加载, 否则报错, 提示升级
     
  总结:
  1. 去除了 子游戏 RC中的配置信息
  2. 数据库中不再包含dll版本信息, 数据库的唯一作用, 是指定加载的dll的名字
  3. dll的版本信息 与 framework中校验

  
    
**** 大厅校验
     client的版本 来源: GameApp.json
     server的版本 来源: setting.h

     校验setting.h 与 GameApp.json的数据
     不需要经过数据库, GameItem中的数据已经删除
*** 版本校验
    内核的真实版本          获取  在DWORD CWHIniData::Get_Code_Kernel_Version()
    framework中的内核版本   获取  在Get_Kernel_Version中获取 (version.h)
    在启动服务的时候进行比较
    比较函数使用Compare_Kernek_Framework()  version.h
    
    framework的真实版本    获取  在在Get_Frame_Version中获取 (version.h)   因为framework是进程
    dll中的framework       获取  在子游戏代码中传入
    在加载dll的时候进行判断, 这个只能是在加载之后校验.  因为加载之前无法从dll中读取数据
    比较函数使用Compare_Dll_Framework
    
    
    client的代码hall版本          获取  client传给服务端, client从gameconfg读取
    server代码的frame版本         获取  在在Get_Frame_Version中获取 (version.h)   因为framework是进程
    在client连接到LogonServer的时候进行判断
    比较函数使用 Compare_Client_LogonServer
    
    client子游戏代码的版本       获取  client传入给GameServer  client在subGame中读取
    server子游戏代码的版本       获取  服务端子游戏代码传入
    在client连接到GameServer的时候进行判断
    比较函数使用 Compare_ClientSubGame_ServerSubGame

*** 断线重连
    1. client掉线
    2. gameserver 记录 断线信息info(userID, serverID)
    3. gameserver将 info发送给logonServer
    4. 情形一
       client 从logonServer登陆
       logonServer 在登录成功的时候, 发送info给client
    5. 情形二
       client 从gameServer登陆
       gameServer在 ID登陆成功之后, 判断info是否存在, 并发送info给client
    6. client在收到info之后
       1) 情形一 logonServer
	  根据serverID 主动发起gameserver的连接请求
       2) 情形二 gameServer
	  在ID登录成功之后, 根据info,来判断是进行断线重连msg的发送, 

    服务端会根据玩家状态判断断线重连标志
    在socket连接关闭的时候, 如果玩家状态为游戏状态, 那么此时就认为是断线了


    现在的断线重连处理:
    1. 断线的时候
       1) 如果 是游戏状态 -- 则当做断线处理
	  1. SetClientReady 设置为false
	  2. 设置用户状态为US_OFFLINE
	  3. 如果是第一次断线， 则开启断线定时器, 定时器到了则让用户站起
       2) 如果不是游戏状态 -- 则将用户数据清空
    2. 断线重连的时候
       1) 根据socketID 找到 BindID, 根据BindID找到对应的用户
       2) 获取用户的桌子 和 椅子
       3) 如果用户能够再次坐下, 则发送数据给客户端


    备注:
    1. 断线重连的时候, 虽然用户对应的BindIndex发生了改变, 但是用户的数据并没有发生改变
       
*** 用户类
    类名: IServerUserItem
    
    实例获取方式:
    //根据socketID 获取bindIndex
    WORD wBindIndex = LOWORD(dwSocketID);
    //根据bindIndex调用CAttemperEngineSink的GetBindUserItem()函数
    IServerUserItem *pIServerUserItem = GetBindUserItem(wBindIndex);
    
    保存的数据 
    1. 连接信息  bindIndex
    2. 游戏信息  TableID, chairID, userStatus

    备注：
    1. 旁观用户放在CTableFrame类的 m_LookonUserItemArray,  不占用椅子数
    2. 游戏用户放在CTableFrame类的 m_TableUserItemArray, 占用椅子数
*** 桌子类
    类名: CTableFrame

    获取实例方式:
    //根据tableID 在CAttemperEngineSink中调用m_TableFrameArray
    CTableFrame* pOldTable = m_TableFrameArray.GetAt(wOldTableID);

    保存的数据:
    1. 
    功能:
    1. 根据userID找到table中的玩家, 根据玩家类的用户状态可以判断当前玩家是旁观还是游戏用户
    2. 提供了用户对椅子的动作 -- 比如坐下, 站起, 旁观
*** 协调服的消息处理
    ITCPSocketService *	 m_pITCPSocketService -> SendData 对应协调服务器的OnEventTCPNetworkRead
    备注: 居然不是对应的sokect, 而是network

*** tableID的问题

  根据tableID 计算出gameID的可行性
  1. tableID的范围  0x186A0   --  0xF423F
     GameID = 8 + 8 + 8 + 8
     其中company是client中写死的
     8位的kindID 可以隐藏在 tableID中

     前提1: nodeID 不需要8位, 一个F表示就可以了
     前提2: roomID 一般一个游戏只开启一个进程, 所以不用处理  可以认为一个gameID只对应着一个serverID

     tableID取值  0x19011 -- 0xF3FFF

     102417 -- 999423

     
     最低位为nodeID 
     次低位 和 次次低位 为kindID 

*** 地址的获取问题
    协调服   --   内核的代码中写死的
    登录服   --   内核的代码中写死的
    游戏服   --   1.frame的代码中写死的(仅仅是用来与数据库中的做校验的)
                  2.数据库中的, 游戏服用到的地址都是数据库中读取的
** 启动流程
  1. 先启动协调服务器 
     开启socket监听

  2. 登录服务器启动 加载列表  CT_LOAD_DB_GAME_LIST
     备注1 登录服务器启动时候， 读取了TypeList， KindList, NodeList

  3. 登录服务器启动成功之后 连接协调服务器     CT_CONNECT_CORRESPOND
     备注1 连接时候 需要用到从配置文件读取到的 addr 和 port(port不存在估计会使用默认值)
     备注2 如果协调服务器没有启动，会报错， 无法进行下面的环节

  4. 协调服务器 收到 socket连接后, 记录该socket对象. 
     备注1 记录方式为 通过对象指针 = (固定结构体指针 + socketID), 因为socketID是唯一的,保证连接对象唯一
     
  5. 游戏服务器启动 加载列表 CT_LOAD_SERVICE_CONFIG
     备注1 游戏服务器启动时候， 读取了GameList 和 RoomList

  6. 游戏服务器启动成功后 连接协调服务器
     备注1 游戏服务器将GameList发送给了协调服务器

  7. 协调服务器 收到游戏服务器连接
     备注1 协调服务器将GameList已全局变量的形式保存着

  8. 协调服务器将 自身的GameList发送给登录服务器

  9. 至此，服务端准备工作完成, 只等待客户端连接
     备注1 此时的登录服务器已经有了TypeList， KindList， NodeList， GameList和RoomList

** 组织架构
*** 游戏process
  控件都在ModuleManager项目
  1. 加载房间
     DlgServerItem.h 
     主界面:  CDlgServerITem
     控  件:  房间列表 CServerListControl
     map   :  CServerInfoBuffer  (ServerID,  tagSQL_OUT_InsertGameRoom) 
  2. 创建房间
     DlgServerWizard.h
     主界面:  CDlgServerWizard
     控件:  
        1) 第一级页面 CDlgServerWizardItem1
	   模块列表  CModuleListControl   -- 类别 CServerinfobuffer
	   map       CModuleInfoBuffer
         2) 第二级页面 CDlgServerWizarditem2
	    tab1  CdlgServerOptionItem1
	    tab2  CDlgServerOptionItem2
	    tab3  CdlgServerOptionitem3
	    tab4  CDlgServerOptionItemCuston???


  零散记录
  1. CServerListControl 和 CModuleListControl都集成ListControl
     其中ListControl又有CListHeaderCtrl
  2. CDlgServerWizardItem1 中 读取GameItem, 之后寻找注册的dll
     校验: 1) dll名字与数据库是否一致  
           2) dll中的文件版本 
	      A. 版本为空, 则认为dll组件无效
              B. 版本 与 数据库中的不一致, 则认为是更新过的
  3. CDlgServeroptionitem2 中 读取 tagGameServiceAttrib 和 tagGameServiceOption
     其中 tagGameserviceattrib 为dll, 即子游戏中配置
          tgGameServiceOption 就是Room信息, 最终会写入到数据库的GameRoomItem中

** 消息号
*** 规则
 ** 简要描述:  登录服 与 其他进程的 消息
 ** 详细描述:  1. 消息号(主 + 子)     2. 结构体
 ** 备注说明:  子消息号的含义: 
 **            1. 第一个字段: 归属标志,        SUB(server接受到的消息)， CMD(server发送出去的消息), DBR(向数据库Response)，DBO(数据库返回的消息)
 **            2. 第二个字段: 消息流向         L: logon;  G:gameserver;  C:client; CP:correspond;  W:web  R子游戏
 **            3. 第三个字段: 主消息号的标志   比如LOGON即为登录模块的消息
 **            4. 之后的字段: 子消息号的含义   比如Accounts表示账号登录
 **           
 **            命名规范
 **            1. 结构体的命名:  在消息号的前面加STR, 比如SUB_CL_LOGON_ACCOUNTS 的为 STR_SUB_CL_LOGON_ACCOUNTS
 **
 **            2. DBO, DBR消息号的命名为:  将SUB替换为DBR或DBO即可
 **
 **            3. 变量的命名规范: 1) 指针加p  2)归属标志SUB  3)主消息号标志  4)子消息号标志
 **
 **            4. 函数的命名:  On_归属标志_主消息号子消息号
 **
 **

*** 消息号整理
主消息号 100  表示game server 与client之间的 子游戏通用消息。 比如 创建房间， 解散房间等
主消息号 200  表示特定子游戏间的消息
** 遗留问题
  2. DBAddr改为16位就报错

  4. 跑马灯消息

  8. 需要配置AccountsDB中的ConfineContent -- 敏感词过滤 -- 用户账号的校验??? 这里应该只校验NickName 用户昵称

* 游戏框架整理 -- client
** 启动流程
   1. 进程 加载Main.unity
   2. Main.unity上的SurfaceMain.cs脚本启动
      1) 获得GameApp实例 (Note: 这里的实例可能是未初始化的)
      2) 初始化ResourceManager实例
      3) 初始化GameApp(主要是各种成员变量)
      4) 在初始化GameApp中的SceneManager成员时, 进入下个场景UI_SCENE_LOGIN
   3. scene_login.unity上的SurfaceLogin.cs脚本启动
      1) surfacelogon在初始化的时候Start()会连接logon server
      2) 发送登录信息之后, logon server返回成功之后
         1) 玩家数据记录在了GameApp的UserInfo中
	 2) 进入下个场景UI_SCENE_HALL
   4. scene_lobby.unit上的SurfaceHall.cs脚本启动
      1) 根据GameApp.UserInfo绘制界面上的数据
      2) 如果用户点击创建|加入房间. 则向Game server发起连接请求, 并且记录了连接动作Action和ServerID
      3) 连接成功之后, 自动进行ID登录
      4) ID登录成功. 
         1) 根据ServerID 设置UI_SCENE_GAME
	 2) 根据Action判断后续流程
      5) 如果流程需要, 则进入下一个场景UI_SCENE_GAME
   5. {game}.unity上的

** 组织架构
*** 消息流程架构
   Btn.cs  -->  HallTransfer.cs  --> SurfaceHall.cs --> AccountService.cs  --> SERVER服务器

   SERVER服务器 --> HallProtocol -> AccountService -> SurfaceHall -> HallTransfer

   | 文件名            | 架构                  | 简要说明                                      | 备注                     |
   |-------------------+-----------------------+-----------------------------------------------+--------------------------|
   | Btn.cs            | btn的响应函数         | 调用hallTransfer的事件                        |                          |
   |-------------------+-----------------------+-----------------------------------------------+--------------------------|
   | HallTransfer.cs   | 1. sub的事件声明      | sub的事件定义在surface中                      | hall界面的总控制类       |
   |                   | 2. cmd的处理函数      |                                               | 这里面的处理都是与ui有关 |
   |-------------------+-----------------------+-----------------------------------------------+--------------------------|
   | SurfaceHall.cs    | 1. 事件的定义 Sub函数 | Sub函数 调用AccountService中函数发送sub消息   |                          |
   |                   | 2. 事件的定义 cmd函数 | Cmd函数 被AccountService中cmd函数调用         |                          |
   |                   |                       | Cmd函数 一般调用HallTransfer中的cmd函数       |                          |
   |-------------------+-----------------------+-----------------------------------------------+--------------------------|
   | AccountService.cs | 1. Sub函数            | Sub函数 被SurfaceHall中调用， 用来发送sub消息 |                          |
   |                   | 2. Cmd事件声明        | Cmd函数 被HallProtocol中调用，                |                          |
   |                   |                       | Cmd函数 一般调用SurfaceHall中cmd函数          |                          |
   |-------------------+-----------------------+-----------------------------------------------+--------------------------|
   | HallProtocol.cs   | cmd处理函数           | 通过AccountService实现具体功能                |                          |
   |-------------------+-----------------------+-----------------------------------------------+--------------------------|

   备注说明:
   1. Sub消息和Cmd消息的处理都是分阶段的
   2. HallTransfer只处理与ui相关的数据
   3. SurfaceHall 处理数据封装
   4. AccountService 处理全局逻辑量
   5. HallProtocol 只校验数据的有效性

   综上， 可得出， 结构体的定义应该在SurfaceHall中成型， 然后发送到AccountService
   因此， 可以直接在SurfaceHall中使用Net中定义的结构体。
   而Btn 与 HallTransfer之间 传递字段即可

*** 脚本目录架构
   Scripts
   -- /Compontes     管理类目录??
   -- -- SceneManager.cs 场景管理类
   -- -- ResourceManager.cs 资源管理类(外部)
   -- -- AccountsService.cs 用户管理类

   -- /UI
   -- -- /Surfaces    surface是场景上的子项??
   -- -- -- SurfaceContainer.cs 子项的列表管理类??
   -- -- -- SurfaceLogin.cs  ui界面与cmd消息号 的交互类
   -- -- /Login
   -- -- -- LoginTransfer.cs ui界面的总控制类， 其底下一般是各种btn的点击函数
   -- -- -- BtnClick_Logon_Account.cs  账号登录按钮的 响应函数

   -- GameRunTimeData.cs  保存了运行时候需要的数据, 比如UserInfo就是其的成员变量
   -- GlobalConst.cs  保存了游戏中的常量
   -- GameApp.cs      Compontes目录下所有类的 管理类



   备注说明:
   SurfaceLogin.cs 与 LoginTransfer.cs
   
   LoginTransfer中有 event注册 和 业务函数两种。
   界面上的btn点击后， 会调用event事件， 该事件会转发到surfaceLogin中处理。

   当surfaceLogin需要将某些数据显示在界面上时候，其会调用LoginTransfer中的业务函数， 达到控制ui的目的

   所以说: LoginTransfer是ui的控制类。  
           SurfaceLogin是ui与cmd消息的中转站
           ui指LoginTransfer, cmd消息指/Components/AccountService.cs

** 脚本说明
   使用到的脚本 有两种， 一种是自己写的， 另一种使用的是第三方库的脚本
   工程目录/Scripts -- 自己的脚本
   工程目录/ThirdParty -- 第三方库脚本
   
   自己脚本目录架构
   工程目录/Scripts/Net --  socket相关脚本， 所有业务逻辑都在这里处理
   工程目录/Scripts/UI  --  界面上挂载的脚本?? TODONOW 所有界面上的挂载脚本只能在当前目录下， 当前目录下脚本再调用其他的脚本
   工程目录/Scripts/Utility -- 实用脚本， 可以理解为与系统相关的脚本
** u3d控件学习
   1. UI Key Navigation(script) 是用来控制tab顺序的
   2. UI Input 是用户输入框. 依赖UI Label和Box Collider
      UI Label是其显示的位置
      Box Collider是其触发区域, 没有该控件, UI Input无法触发
** 遗留问题
   1. 游戏服逻辑需要重新整理
   2. 子游戏脚本需要重新整理
   3. 所有界面上的脚本只能使用UI中的
   4. scene_lobby.unity改名为scene_hall.unity
* 游戏框架整理 -- 数据库
** 白名单
   通过白名单来校验是否是公司的客户
** 字段含义
  1. joinID 之前是用来区分 pc 和mobile的
     现在的框架已经删除

  2. GSP_GP 开头的 为登录服 调用的?  platform？？
     GR   room??
     GSP_GS 开头的 为游戏服 调用的?  

  3. QPAccountsDB 中的 SystemStreamInfo 记录了 当天玩家注册次数  和 登录次数
     有必要 自己记录保存吗???

  4. System开头的表 都是起 统计或者维护的信息,   非业务逻辑

  5. AccountsDB 中的 SystemStatusInfo 可以控制游戏的注册 登录等操作
  
* 游戏框架整理 -- 服务器子游戏
** 组织架构
   FrameWork -->  TableFrameSink --> GameData  --> GameInterface(CGameLogic, CGameAccess)

   备注: 1. tableFrameSink只是处理流程, 所有的数据都在GameData中
         2. GameInterface 是 GameData的基类, 使用的时候 使用GameInterface.  GameInterface是GameData的外在表现类
	 3. CGameCardConfig  和 CGamePlayerConfig 是GameData的辅助类.
	 4. SubGameRule重载了GameData中的部分函数. 所以GameData创建的时候实际上是创建了SubGameRule对象

** 牌类数据描述
   玩家 使用16位表示
   高四位 表示 玩家类型的ID  -- 比如 地主, 农民
   再四位 表示 玩家数量
   低8位  表示 玩家手牌数量


   牌使用16位表示
   高四位  表示 卡牌点数
   中四位  表示 卡牌颜色
   低8位   表示 卡牌类型组 -- groupID, 配置文件挂钩
   
   1方块; 2梅花; 3红桃; 4黑桃; 5表示特殊牌,  比如大王小王
   大王小王 花色为5， 值分别为 15 14

** 约定俗称 | 命名规范
   1. log日志的命名 应该是  kind_node.log 
* 游戏框架整理 -- 客户端子游戏
** 杨浩然对子游戏的认知
************************************
       两张牌子游戏简要文档
************************************

====Logic 文件夹====

GameConfig 类 ：类中的方法大多与经验等级，VIP等级有关，不清楚为什么叫这个类名；

GameEngine 类 ：该类继承 PokerGameAgent 类，类中并没有子类独有的方法；

GameLogic 类 ：该类中有大量的常量值来表示游戏的游戏状态，牌型定义，花色数值的掩码；

	       该类中还有跟花色牌型有关的获取方法，以及一些比较方法和获取牌型的方法；

GameMsg 类 ： 该类中全部是游戏中所要使用的字符串常量

GameXY 类 ： 该类中有所有与服务器交互所使用的消息号和数据结构体(结构体并不全面)；

====================


====Share/Controls 文件夹====

该文件夹中只具体看过UIGard类和UICardControl类

UICard 类 ： 该类挂载在Card预制体上，存放卡牌的一些相应界面显示信息，和一些扑克牌的相应方法(并未使用)

UICardControl 类 ： 该类挂载在每个玩家父节点下的ctr_hand_cards对象上，主要起控制该节点生成卡牌和卡牌的摆放位置，卡牌数据的赋值，卡牌的反转，发牌等卡牌在Game视图中的控制

====================


====UI 文件夹====

该文件夹下所有的脚本都挂载在相应的 scene_ 节点上，例如 UIGame 挂载在 scene_game 节点上

(该类已经被主程按方法拆分)
UIGame 类 ： 这个类是一个大的类，界面中的大多控件的回调方法都在这个类中实现，跟服务器交互的委托方法也在这个类中：具体在框架消息和游戏消息两个region中，根据对应消息号会调用相应的方法；

	     该类中有大量的公有 私有变量，注意不要随意拖动场景中的节点层级，否则会使这个脚本的大多变量找寻不到相应的场景对象，包括名字也不要随意修改！！！

====================


PS ： 

一、从scene_lobby场景进入相应的子游戏是有kindID来控制的，这个ID是从服务器获取的，所以如果roomId报错空引用可能：

1.配置文件没有配置正确
2.BtnClick_CreateRoom 和 BtnClick_JoinRoom类中的kindID没有修改为要运行的游戏
3.服务器崩了

二、showWindow是一个很有意思的类，大厅中的很多窗口的显示与隐藏都是靠这个脚本来实现的

三、游戏有屏幕尺寸自适应脚本，叫 CGetScreenWH 实现方法挺暴力不过也挺有效

四、其余没有解释的脚本是没来得及看完的，不过都是控制相应的控件，可以自行查找引用方可找见所挂载对象


* client未完成事项
** ConstData中的一些数据需要删除
** GameData中的数据需要整理
** 图集问题
* server未完成事项
** 客户端游戏更新
* 子游戏未完成事项
** dll名字
   dll名字改为自动生成
** 子游戏的版本 应该与 大厅分离, 不然每次大厅改动, 都需要导致子游戏重新编译
* 后台未完成事项
* 数据库未完成事项
